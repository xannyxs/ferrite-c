#include <ferrite/elf.h>
#include <ferrite/errno.h>
#include <ferrite/ksyms.h>
#include <ferrite/module.h>
#include <ferrite/string.h>

#include "drivers/printk.h"
#include "memory/kmalloc.h"

// tmp
unsigned char module_o[] = {
    0x7f, 0x45, 0x4c, 0x46, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00,
    0x0c, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x83, 0xec, 0x18, 0x68, 0x00, 0x00, 0x00, 0x00,
    0xe8, 0xfc, 0xff, 0xff, 0xff, 0x31, 0xc0, 0x83, 0xc4, 0x1c, 0xc3, 0x2e,
    0x8d, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x8d, 0x74, 0x26, 0x00,
    0x83, 0xec, 0x18, 0x68, 0x14, 0x00, 0x00, 0x00, 0xe8, 0xfc, 0xff, 0xff,
    0xff, 0x83, 0xc4, 0x1c, 0x31, 0xc0, 0xc3, 0x48, 0x65, 0x6c, 0x6c, 0x6f,
    0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65,
    0x21, 0x0a, 0x00, 0x47, 0x6f, 0x6f, 0x64, 0x62, 0x79, 0x65, 0x20, 0x66,
    0x72, 0x6f, 0x6d, 0x20, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x21, 0x0a,
    0x00, 0x00, 0x47, 0x43, 0x43, 0x3a, 0x20, 0x28, 0x47, 0x4e, 0x55, 0x29,
    0x20, 0x31, 0x33, 0x2e, 0x33, 0x2e, 0x30, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x18, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x47, 0x4e, 0x55, 0x00,
    0x02, 0x00, 0x01, 0xc0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0xc0, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0xf1, 0xff, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x05, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
    0x12, 0x00, 0x01, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x12, 0x00, 0x01, 0x00,
    0x00, 0x62, 0x61, 0x73, 0x69, 0x63, 0x5f, 0x6d, 0x6f, 0x64, 0x75, 0x6c,
    0x65, 0x2e, 0x63, 0x00, 0x69, 0x6e, 0x69, 0x74, 0x5f, 0x6d, 0x6f, 0x64,
    0x75, 0x6c, 0x65, 0x00, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x6b, 0x00, 0x63,
    0x6c, 0x65, 0x61, 0x6e, 0x75, 0x70, 0x5f, 0x6d, 0x6f, 0x64, 0x75, 0x6c,
    0x65, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x02, 0x00, 0x00,
    0x09, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00,
    0x01, 0x02, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00,
    0x00, 0x2e, 0x73, 0x79, 0x6d, 0x74, 0x61, 0x62, 0x00, 0x2e, 0x73, 0x74,
    0x72, 0x74, 0x61, 0x62, 0x00, 0x2e, 0x73, 0x68, 0x73, 0x74, 0x72, 0x74,
    0x61, 0x62, 0x00, 0x2e, 0x72, 0x65, 0x6c, 0x2e, 0x74, 0x65, 0x78, 0x74,
    0x00, 0x2e, 0x64, 0x61, 0x74, 0x61, 0x00, 0x2e, 0x62, 0x73, 0x73, 0x00,
    0x2e, 0x72, 0x6f, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x73, 0x74, 0x72, 0x31,
    0x2e, 0x31, 0x00, 0x2e, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x00,
    0x2e, 0x6e, 0x6f, 0x74, 0x65, 0x2e, 0x47, 0x4e, 0x55, 0x2d, 0x73, 0x74,
    0x61, 0x63, 0x6b, 0x00, 0x2e, 0x6e, 0x6f, 0x74, 0x65, 0x2e, 0x67, 0x6e,
    0x75, 0x2e, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x79, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00,
    0x09, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x6c, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x25, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x73, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x3f, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x9d, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00,
    0x07, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xb0, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xd8, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x0a, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x01, 0x00, 0x00,
    0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x8c, 0x01, 0x00, 0x00, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
unsigned int module_o_len = 984;

/* Private */

static int verify_elf_header(elf32_hdr_t* hdr)
{
    if (hdr->e_ident[EI_MAG0] != ELFMAG0 || hdr->e_ident[EI_MAG1] != ELFMAG1
        || hdr->e_ident[EI_MAG2] != ELFMAG2
        || hdr->e_ident[EI_MAG3] != ELFMAG3) {
        printk("Not a valid ELF file\n");
        return -EINVAL;
    }

    if (hdr->e_ident[EI_CLASS] != ELFCLASS32) {
        printk("Not a 32-bit ELF file\n");
        return -EINVAL;
    }

    if (hdr->e_ident[EI_DATA] != ELFDATA2LSB) {
        printk("Wrong endianness (expected little-endian)\n");
        return -EINVAL;
    }

    if (hdr->e_ident[EI_VERSION] != EV_CURRENT) {
        printk("Unsupported ELF version\n");
        return -EINVAL;
    }

    return 0;
}

// static int apply_relocation(
//     Elf32_Rel* rel,
//     Elf32_Sym* symtab,
//     char* strtab,
//     char* section_data,
//     unsigned long section_addr
// )
// {
//     unsigned long* location = (unsigned long*)(section_data + rel->r_offset);
//     int sym_idx = ELF32_R_SYM(rel->r_info);
//     int rel_type = ELF32_R_TYPE(rel->r_info);
//
//     Elf32_Sym* sym = &symtab[sym_idx];
//     char* sym_name = strtab + sym->st_name;
//
//     unsigned long sym_addr = 0;
//
//     // Check if symbol is defined in the module itself
//     if (sym->st_shndx != 0) { // SHN_UNDEF = 0
//         // Symbol is in the module - use its offset from module base
//         sym_addr = (unsigned long)section_data + sym->st_value;
//     } else {
//         // External symbol - look it up in kernel
//         sym_addr = ksym_lookup(sym_name);
//         if (sym_addr == 0) {
//             printk("Undefined symbol: %s\n", sym_name);
//             return -EINVAL;
//         }
//     }
//
//     switch (rel_type) {
//     case R_386_32:
//         // S + A (Symbol + Addend)
//         *location += sym_addr;
//         break;
//
//     case R_386_PC32: {
//         // S + A - P (Symbol + Addend - Position)
//         unsigned long P = section_addr + rel->r_offset;
//         *location += sym_addr - P;
//         break;
//     }
//
//     default:
//         printk("Unknown relocation type: %d\n", rel_type);
//         return -EINVAL;
//     }
//
//     return 0;
// }

/* Public */

int sys_delete_module(char const* name_user, unsigned int flags)
{
    (void)flags;
    (void)name_user;

    return -ENOSYS;
}

int sys_init_module(void* mod, unsigned long len, char* const args)
{
    (void)args;
    (void)len;

    int error = 0;
    mod = module_o;
    len = module_o_len;

    elf32_hdr_t* ehdr = (elf32_hdr_t*)mod;
    error = verify_elf_header(ehdr);
    if (error < 0) {
        return error;
    }

    elf32_shdr_t* sections = (elf32_shdr_t*)((char*)mod + ehdr->e_shoff);
    elf32_shdr_t* shstrtab_hdr = &sections[ehdr->e_shstrndx];
    char* shstrtab = (char*)mod + shstrtab_hdr->sh_offset;

    elf32_shdr_t* symtab_hdr = NULL;
    elf32_shdr_t* strtab_hdr = NULL;
    elf32_shdr_t* text_hdr = NULL;
    elf32_shdr_t* rodata_hdr = NULL;

    for (int i = 0; i < ehdr->e_shnum; i++) {
        char* name = shstrtab + sections[i].sh_name;

        if (strcmp(name, ".symtab") == 0) {
            symtab_hdr = &sections[i];
        } else if (strcmp(name, ".strtab") == 0) {
            strtab_hdr = &sections[i];
        } else if (strcmp(name, ".text") == 0) {
            text_hdr = &sections[i];
        } else if (strncmp(name, ".rodata", 7) == 0) {
            rodata_hdr = &sections[i];
        }
    }

    if (!symtab_hdr || !strtab_hdr || !text_hdr) {
        printk("Missing required sections\n");
        return -EINVAL;
    }

    unsigned long total_size = 0;
    unsigned long text_offset = 0;
    unsigned long rodata_offset = 0;

    text_offset = total_size;
    total_size += text_hdr->sh_size;

    if (rodata_hdr) {
        rodata_offset = total_size;
        total_size += rodata_hdr->sh_size;
    }

    void* mod_mem = kmalloc(total_size);
    if (!mod_mem) {
        return -ENOMEM;
    }

    printk("Allocated %lu bytes at 0x%x for module\n", total_size, mod_mem);

    memcpy(
        (char*)mod_mem + text_offset, (char*)mod + text_hdr->sh_offset,
        text_hdr->sh_size
    );
    printk("  .text: offset 0x%x, size %u\n", text_offset, text_hdr->sh_size);

    if (rodata_hdr) {
        memcpy(
            (char*)mod_mem + rodata_offset, (char*)mod + rodata_hdr->sh_offset,
            rodata_hdr->sh_size
        );
        printk(
            "  .rodata: offset 0x%x, size %u\n", rodata_offset,
            rodata_hdr->sh_size
        );
    }

    unsigned long section_addrs[256] = { 0 };
    for (int i = 0; i < ehdr->e_shnum && i < 256; i++) {
        char* name = shstrtab + sections[i].sh_name;

        if (strcmp(name, ".text") == 0) {
            section_addrs[i] = (unsigned long)mod_mem + text_offset;
        } else if (strncmp(name, ".rodata", 7) == 0) {
            section_addrs[i] = (unsigned long)mod_mem + rodata_offset;
        }
    }

    Elf32_Sym* symtab = (Elf32_Sym*)((char*)mod + symtab_hdr->sh_offset);
    char* strtab = (char*)mod + strtab_hdr->sh_offset;

    for (int i = 0; i < ehdr->e_shnum; i++) {
        if (sections[i].sh_type != SHT_REL) {
            continue;
        }

        char* name = shstrtab + sections[i].sh_name;
        if (strcmp(name, ".rel.text") != 0) {
            continue;
        }

        printk("Applying relocations from %s\n", name);

        Elf32_Rel* rels = (Elf32_Rel*)((char*)mod + sections[i].sh_offset);
        int num_rels = sections[i].sh_size / sizeof(Elf32_Rel);

        for (int j = 0; j < num_rels; j++) {
            unsigned long* location
                = (unsigned long*)((char*)mod_mem + text_offset
                                   + rels[j].r_offset);
            int sym_idx = ELF32_R_SYM(rels[j].r_info);
            int rel_type = ELF32_R_TYPE(rels[j].r_info);

            Elf32_Sym* sym = &symtab[sym_idx];
            unsigned long sym_addr = 0;

            if (ELF32_ST_TYPE(sym->st_info) == STT_SECTION) {
                sym_addr = section_addrs[sym->st_shndx];
            } else if (sym->st_shndx == 0) {
                char* sym_name = strtab + sym->st_name;
                sym_addr = ksym_lookup(sym_name);
                if (sym_addr == 0) {
                    printk("Undefined symbol: %s\n", sym_name);
                    kfree(mod_mem);
                    return -EINVAL;
                }
            } else {
                sym_addr = section_addrs[sym->st_shndx] + sym->st_value;
            }

            switch (rel_type) {
            case R_386_32:
                *location += sym_addr;
                break;

            case R_386_PC32: {
                unsigned long P
                    = (unsigned long)mod_mem + text_offset + rels[j].r_offset;
                *location += sym_addr - P;
                break;
            }

            default:
                printk("Unknown relocation type: %d\n", rel_type);
                kfree(mod_mem);
                return -EINVAL;
            }
        }
    }

    int (*init_fn)(void) = NULL;
    int num_syms = symtab_hdr->sh_size / sizeof(Elf32_Sym);

    for (int i = 0; i < num_syms; i++) {
        char* name = strtab + symtab[i].st_name;
        if (strcmp(name, "init_module") == 0) {
            void* addr = (char*)mod_mem + text_offset + symtab[i].st_value;
            memcpy(&init_fn, &addr, sizeof(init_fn));
            break;
        }
    }

    if (!init_fn) {
        printk("init_module function not found\n");
        kfree(mod_mem);
        return -EINVAL;
    }

    printk("Calling init_module at 0x%x...\n", init_fn);

    int ret = init_fn();
    if (ret < 0) {
        printk("init_module failed with error %d\n", ret);
        kfree(mod_mem);
        return ret;
    }

    printk("Module loaded successfully!\n");
    return 0;
}
